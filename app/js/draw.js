import $ from 'jquery';
import { entryArray } from './entry.js';
import { textData } from './copy.js';

/**
 * キルレートの表示の色分け
 */
$('#season').on(('click'), function () {
  $('.career-kill-rate').removeClass("text-green-500 animate-fadeIn");
  $('.career-kill-rate').addClass("text-gray-500");
  $('.season-kill-rate').removeClass("text-gray-500 animate-fadeIn");
  $('.season-kill-rate').addClass("text-green-500 animate-fadeIn");
});
$('#career').on(('click'), function () {
  $('.season-kill-rate').removeClass("text-green-500 animate-fadeIn");
  $('.season-kill-rate').addClass("text-gray-500");
  $('.career-kill-rate').removeClass("text-gray-500 animate-fadeIn0");
  $('.career-kill-rate').addClass("text-green-500 animate-fadeIn");
});
$('#custom').on(('click'), function () {
  if ($(this).prop('checked')) {
    $('.custom-kill-rate').addClass("flex");
    $('.custom-kill-rate').removeClass("hidden");
  } else {
    $('.custom-kill-rate').removeClass("flex");
    $('.custom-kill-rate').addClass("hidden");
  }
});

// 抽選をする
function draw() {
  $('#draw-btn .loading').css('display', 'block');
  $('#draw').empty();
  $('#success-message').empty();
  $('#error-message').empty();
  $('.entry-error').remove();
  $('#copy').remove();
  $('.entry').removeClass('warning');
  $('.csv-import-message').remove();
  // アニメーション用classを削除
  $('#success-message').removeClass("animate-fadeIn");
  $('#error-message').removeClass("animate-fadeIn");

  // 入力フォームのエラーメッセージ
  const playerNameClass = document.querySelectorAll(".input-player");
  for (let i = 0; i < entryArray.length; i++) {
    if (entryArray[i] === undefined) {
      $('#entry').after(`
      <div class="entry-error text-red-700 text-2xl mt-5 animate-fadeIn text-center">
        <p>No.${i + 1} player name has not been entered.</p>
      </div>`);
      playerNameClass[i].classList.add("error-empty");
      // 抽選中の Loading を削除
      $('#draw-btn .loading').css('display', 'none');
      return;
    } else {
      playerNameClass[i].classList.remove("error-empty");
    }
  }

  // entryArray を deep copy
  const drawArray = entryArray.map(elem => {
    if (Array.isArray(elem)) {
      return [...elem]
    } else if (typeof (elem) == "object") {
      return { ...elem }
    } else return elem
  });

  // 抽選用の連想配列を作り直す（シーズンキルレかキャリアキルレかカスタムキルレのどれを使うか）
  for (let i = 0; i < drawArray.length; i++) {
    if ($(`.custom-kill-rate input`).eq(i).val() !== "" && ($('#custom').prop('checked'))) {
      // カスタムキルレートの入力があれば
      drawArray[i].kill_rate = Number($(`.custom-kill-rate input`).eq(i).val());
      delete drawArray[i].career;
      delete drawArray[i].season;
    } else if ($('#career').prop("checked")) {
      // キャリアキルレートを使う
      drawArray[i].kill_rate = entryArray[i].career;
      delete drawArray[i].career;
      delete drawArray[i].season;
    } else if ($('#season').prop("checked")) {
      // シーズンキルレートを使う
      drawArray[i].kill_rate = entryArray[i].season;
      delete drawArray[i].career;
      delete drawArray[i].season;
    }
  }

  // 抽選する条件
  const adjust = Number(document.getElementById("adjust").value);

  /**
   * 配列をシャッフルする関
   * @returns {array}
   */
  const shuffle = ([...array]) => {
    for (let i = array.length - 1; i >= 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  /**
   * 組み合わせ抽選の処理
   */
  let count = 1;
  let limit = 1000000;
  setTimeout(() => {
    while (count <= limit) {
      //シャッフルした配列
      let shuffleArray = shuffle(drawArray);

      /**
       * while for 文でチーム分けするために配列を分割
       */
      let squadArray = [];
      let k = 0;
      let m = 0;
      // 抽選されたスクワッドのキルレート
      let squadKillRateSum;
      let squadKillRateSumArray = [];

      // プレイヤー数
      const playerSum = entryArray.length;

      // 最後のスクワッドを作る処理
      if (playerSum % 3 == 1) {
        while (k < playerSum) {
          // 余りが1人で2人組スクワッドを2つ作る場合
          if (k == playerSum - 4) {
            // シャッフルされたメンバーの配列をスクワッド毎に分割
            squadArray.push(shuffleArray.slice(k, playerSum - 2));
            squadArray.push(shuffleArray.slice(k + 2, playerSum));
            squadKillRateSum = squadArray[m].reduce((sum, j) => sum + j.kill_rate, 0);
            // キルレートの合計を配列に追加
            squadKillRateSumArray.push(squadKillRateSum);
            // キルレートの合計を配列に追加
            squadKillRateSumArray.push(squadKillRateSum);
            k = k + 3;
          }
          // 通常の処理
          else {
            // シャッフルされたメンバーの配列をスクワッド毎に分割
            squadArray.push(shuffleArray.slice(k, k + 3));
            squadKillRateSum = squadArray[m].reduce((sum, j) => sum + j.kill_rate, 0);
            // キルレートの合計を配列に追加
            squadKillRateSumArray.push(squadKillRateSum);
          }
          (k = k + 3), m++;
        }
      }
      // 通常の処理
      else {
        for (let i = 0; i < playerSum; i = i + 3, m++) {
          // シャッフルされたメンバーの配列をスクワッド毎に分割
          squadArray.push(shuffleArray.slice(i, i + 3));
          squadKillRateSum = squadArray[m].reduce((sum, j) => sum + j.kill_rate, 0);
          // キルレートの合計を配列に追加
          squadKillRateSumArray.push(squadKillRateSum);
        }
      }

      /**
       * 最大最小の合計キルレートの差分を判定
       * @returns {boolean} 合計キルレートの差分が調整範囲(adjust)以内なら true
       */
      const compare = () => {
        let maxKR = Math.max(...squadKillRateSumArray);
        let minKR = Math.min(...squadKillRateSumArray);
        let compareMaxMin = maxKR - minKR;
        return compareMaxMin < adjust
      };

      if (compare()) {
        // トータルキルレート値
        const killRateSum = drawArray.reduce((sum, i) => sum + i.kill_rate, 0);
        // 平均のキルレート値
        const killRateAverage = killRateSum / drawArray.length;
        // スクワッドの最大最小キルレートを変数にする
        let squadMaxKillRate = Math.max(...squadKillRateSumArray);
        let squadMinKillRate = Math.min(...squadKillRateSumArray);
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

        // 抽選された各スクワッドの合計キルレートと全体の合計キルレートを比較し条件分岐
        $('#success-message').append(
          `<div class="flex justify-center items-center">
            <h3 class="mr-10 text-green-700 text-5xl font-barlow_condensed font-bold">Success!!</h3>
            <div class="text-xl">
              <p>The ${count.toLocaleString()}th drawing found a combination that meets the requirements.</p>
              <p class="mt-3">The average kill rate for this tournament is <span class="text-amber-500">${killRateAverage.toFixed(2)}</span>.<br>Maximum kill rate difference is <span class="text-amber-500">${(squadMaxKillRate.toFixed(2) - squadMinKillRate.toFixed(2)).toFixed(2)}</span>.</p>
            </div>
          </div>`
        );

        // 分割されたスクワッドの配列をキルレート順にソート
        for (let i = 0; i < squadArray.length; i++) {
          squadArray[i].sort((first, second) => first.kill_rate - second.kill_rate);
        }

        // 余りのスクワッドが最後にならないように再度シャッフル(Groupをシャッフル)
        squadArray = shuffle(squadArray);

        let squadNewKRSumAry = [];

        // スクワッドのDivを作成しメンバーを配置
        for (let i = 0; i < squadArray.length; i++) {
          let createSquadSection = document.createElement("section");
          let createSquadDiv = document.createElement("div");
          createSquadDiv.classList.add("bg-slate-800", "p-4", "mt-2");
          $('#draw').append(createSquadSection);
          createSquadSection.appendChild(createSquadDiv);
          createSquadSection.insertAdjacentHTML("afterbegin", `<h2 class="text-3xl font-anton">Group ${alphabet[i]}</h2>`);
          for (let j = 0; j < squadArray[i].length; j++) {
            let resultHtml = `
            <div class="player grid grid-cols-[50px_1fr_40px] gap-3 mt-3">
              <figure><img src="${squadArray[i][j].avatar}"></figure>
              <div class="font-barlow_condensed text-xl leading-none break-all">${squadArray[i][j].player_name}</div>
              <div class="font-bebas_neue text-2xl leading-none text-right">${squadArray[i][j].kill_rate.toFixed(2)}</div>
            </div>`;
            createSquadDiv.insertAdjacentHTML("afterbegin", resultHtml);
            createSquadSection.appendChild(createSquadDiv);
          }
          createSquadDiv.insertAdjacentHTML("afterbegin", `
          <div class="player-header font-caveat text-xl grid grid-cols-[1fr_70px] justify-items-center mb-6">
            <div class="pl-7">player name</div>
            <div>kill rate</div>
          </div>`);
          // スクワッドの合計・平均キルレート
          let squadNewKRSum = squadArray[i].reduce((sum, j) => sum + j.kill_rate, 0);
          squadNewKRSumAry.push(squadNewKRSum);
          createSquadDiv.insertAdjacentHTML("beforeend", `<div class="kill-rate-average font-caveat text-xl mt-5 text-right">Average kill rate: ${(squadNewKRSumAry[i] / squadArray[i].length).toFixed(2)}</div>`);
          createSquadDiv.insertAdjacentHTML("beforeend", `<div class="kill-rate-sum text-xl font-caveat text-right"><span>Total kill rate: ${squadNewKRSumAry[i].toFixed(2)}</span></div>`);
        }

        // スクワッドの最大最小キルレートを変数にする
        squadMaxKillRate = Math.max(...squadNewKRSumAry);
        squadMinKillRate = Math.min(...squadNewKRSumAry);
        // 配列の順序[i]を取得
        const squadMaxKillRatePosition = squadNewKRSumAry.indexOf(squadMaxKillRate);
        const squadMinKillRatePosition = squadNewKRSumAry.indexOf(squadMinKillRate);

        // 最強スクワッドにclassを追加
        const strongSquad = document.querySelectorAll("#draw > section");
        strongSquad[squadMaxKillRatePosition].classList.add("strong-squad");

        // 最弱スクワッドにclassを追加
        const weakSquad = document.querySelectorAll("#draw > section");
        weakSquad[squadMinKillRatePosition].classList.add("weak-squad");

        textData(squadArray, squadNewKRSumAry, killRateAverage, squadMaxKillRate, squadMinKillRate);

        // エントリープレイヤーの重複チェック
        const duplicateArrey = [];
        entryArray.filter((val) => {
          // player_name だけを配列にする
          duplicateArrey.push(val.player_name)
        });
        // 重複しているエントリープレイヤー
        const duplicatePlayer = duplicateArrey.filter(function (val, i, array) {
          return !(array.indexOf(val) === i);
        });
        if (duplicatePlayer.length) {
          $('#error-message').append(`<p class="warning">Warning: Player name <span class="font-bold">[${duplicatePlayer}]</span> is duplicated.</p>`);
          for (let i = 0; i < duplicatePlayer.length; i++) {
            for (let j = 0; j < entryArray.length; j++) {
              if (duplicatePlayer[i] == entryArray[j].player_name) {
                $('.entry').eq(j).addClass('warning');
              }
            }
          }
          $('#error-message').addClass("animate-fadeIn");
        }

        // 抽選中の Loading を削除
        $('#draw-btn .loading').css('display', 'none');
        $('#success-message').addClass("animate-fadeIn");
        break;
      } else if (count == limit) {
        $('#error-message').addClass("animate-fadeIn");
        $('#error-message').append(`
        <div class="flex justify-center items-center">
          <h3 class="mr-10 text-red-700 text-5xl font-barlow_condensed font-bold">Not Found.</h3>
          <div class="text-xl">
            <p>We have drawn ${count.toLocaleString()} and could not find a combination that meets the requirements.<br>
            Please perform the drawing again or change the kill rate tolerance.</p>
          </div>
        </div>`);
        // 抽選中の Loading を削除
        $('#draw-btn .loading').css('display', 'none');
      }
      count++;
    }
  }, 100);
};

// Draw ボタンクリック時の CSS 操作
$('#draw-btn button').on('mousedown', () => {
  $('button').addClass('focus:ring-4 focus:ring-blue-300')
});
$('#draw-btn button').on('mouseup', () => {
  $('button').removeClass('focus:ring-4 focus:ring-blue-300')
});


export { draw }